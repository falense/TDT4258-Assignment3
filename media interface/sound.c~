
int soundDeviceID = -1;

#include "sound.h"
void initSound(){
///dev/ttyPA1
	soundDeviceID = open("/dev/dsp",O_WRONLY );

	if(soundDeviceID < 0)
	{
		printf("Didnt manage to open sound device.");
		exit(0);
	}
		;  // handle error
	int sampleRate = DSP_SAMPLERATE;
	ioctl(soundDeviceID,SOUND_PCM_WRITE_RATE,&sampleRate);
}
void closeSound(){
	close(soundDeviceID);

}
void writeSoundValue(char *buffer, unsigned int length){
	ssize_t written = write(soundDeviceID, buffer,length);
	if(written >= 0)
		;  // handle successful write (which might be a partial write!)
	else if(errno == EWOULDBLOCK)
		printf("Error writing");
	else printf("Error writing");
}
int soundState = 0;
int samplesPerPeriod = 150;


/* Wave sample generating functions 
Each of these functions can be used with the sounds created. 
In our humble opinion square waves sound best while pyramidWave and sinWave each have their respective quirks*/

/*Simples square wave function, either its on or its off. 
This is defined via what tone is currently playing on the channel we are generating for and what state we currently are at.
State is a constantly incrementing value for each interrupt. This makes the function below able to determine where it should be in its waveform */
short squareWave(){
	if (soundState%samplesPerPeriod < samplesPerPeriod/2)
		return 100;
	else return -100;
}

/*Pyramid wave function.  This is defined via what tone is currently playing on the channel we are generating for and what state we currently are at. 
State is a constantly incrementing value for each interrupt. This makes the function below able to determine where it should be in its waveform */
short pyramidWave(){
	int period = soundState%samplesPerPeriod;
	if (period < samplesPerPeriod/4){
		return (period*100/(samplesPerPeriod/4));
	}
	else if(period < samplesPerPeriod/2){
		return (100-(period-samplesPerPeriod/4)*200/(samplesPerPeriod/2));
	}
	else {
		return -100+((period-((samplesPerPeriod*3)/4))*100/(samplesPerPeriod/4));
	}
}

short sinTable[] = {0, 6, 12, 18, 24, 30, 36, 42, 48, 53, 58, 63, 68, 72, 77, 80, 84, 87, 90, 92, 95, 96, 98, 99, 99, 99, 99, 99, 98, 96, 95, 93, 90, 87, 84, 80, 77, 72, 68, 63, 58, 53, 48, 42, 36, 31, 25, 18, 12, 6, 0, -6, -12, -18, -24, -30, -36, -42, -48, -53, -58, -63, -68, -72, -76, -80, -84, -87, -90, -92, -95, -96, -98, -99, -99, -99, -99, -99, -98, -96, -95, -93, -90, -87, -84, -81, -77, -73, -68, -63, -59, -53, -48, -42, -37, -31, -25, -19, -12, -6};

/*Simple sinus aproximation with a lookup table.  
This is defined via what tone is currently playing on the channel we are generating for and what state we currently are at. 
State is a constantly incrementing value for each interrupt. This makes the function below able to determine where it should be in its waveform */
short sinWave(){
	int period = soundState%samplesPerPeriod;
	short index = (period*100)/samplesPerPeriod;
	return sinTable[index%100];

}

short waveFunction(){
	soundState++;
	return (unsigned int)squareWave();
}


//Sets the frequency the abdac should play
void setFrequency(double hertz){
	//If the hertz given is over 1 we assume we want to play an actual sound
	if (hertz > 1.0){
		samplesPerPeriod = DSP_SAMPLERATE /hertz;
	}
}

/*This is an effect that sounds a bit like a sonar ping, cool sound effect not much more. 
SpxID and volume is reset after running as these are persistant and we wouldnt want the sound to be played forever.*/
void effect_sonar(){
	int i,j;
	for (j = 0; j < 3; j++)
	for (i = 0; i <  20; i++){
		setVolume(0, 200/(i+1));
		setFrequency(323,0);
		naive_wait(6000);
		setFrequency(0,0);
		naive_wait(3000);
	}
	setVolume(0,  200);
	spxID = 0;
}

/*A rising pitch sound. SpxID is reset after running this sound to avoid eternal loop,
 in addition the frequency is reset to 0 (ie. channel stopped/no sound) as otherwise it would just keep the same tone. */
void effect_rising(){
	short i;
	for (i = 0; i <  20; i++){
		setFrequency(323+i*20,0);
		naive_wait(3000);
	}
	setFrequency(0,0);
	spxID = 0;
}

/*A falling pitch sound. SpxID is reset after running this sound to avoid eternal loop,
 in addition the frequency is reset to 0 (ie. channel stopped/no sound) as otherwise it would just keep the same tone. */
void effect_falling(){
	short rand = 723;
	short i;
	for (i = 0; i <  20; i++){
		setFrequency(rand-i*20,0);
		naive_wait(3000);
	}
	setFrequency(0,0);
	spxID = 0;
}
/*Sound effect closest we could get to a shot. 
SpxID is reset after running this sound to avoid eternal loop,
in addition the frequency is reset to 0 (ie. channel stopped/no sound) as otherwise it would just keep the same tone.*/
void effect_shot(){

	tempo = 1;
	short i;
	for (i = 0; i <  20; i++){
		setFrequency(323-i*20,0);
		naive_wait(3000);
	}
	setFrequency(0,0);
	spxID = 0;

}
/*Multiple shot effects in fast repetition. SpxID is reset after running this sound to avoid eternal loop, 
in addition the frequency is reset to 0 (ie. channel stopped/no sound) as otherwise it would just keep the same tone.*/
void effect_machinegun(){
	short i, j;
	for (j = 0; j < 15; j++)
	for (i = 0; i <  20; i++){
		setFrequency(323-i*20,0);
		naive_wait(100);
	}
	setFrequency(0,0);
	spxID = 0;
}
/*Combination of 3 rising and 1 falling effect, making this sound a bit like supermario. 
SpxID is reset after running this sound to avoid eternal loop,
 in addition the frequency is reset to 0 (ie. channel stopped/no sound) as otherwise it would just keep the same tone.*/
void effect_supermario(){
	short i;
	for (i=0; i < 3; i++){
		short j;
		for (j = 0; j <  20; j++){
			setFrequency(323+j*20,0);
			naive_wait(1200);
		}
	}
	for (i = 0; i <  20; i++){
		setFrequency(723-i*20,0);
		naive_wait(3000);
	}
	setFrequency(0,0);
	spxID = 0;
}
void playSounds(){

	char data[SOUNDBURSTWRITE+1];
	for (int i = 0; i < SOUNDBURSTWRITE; i++)
		data[i] = waveFunction();	
	writeSoundValue(&data,SOUNDBURSTWRITE);
}
